package com.digi.connector.config;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;

import com.digi.connector.config.ConfigGenerator.FileType;

public class FileSourceCcapi extends FileGenerator {

    private static FileType fileType = FileType.SOURCE;
    private static String SOURCE_NAME = ConfigGenerator.getCustomPrefix() + "ccapi_rci_data.c";
    private static String HEADER_NAME = ConfigGenerator.getCustomPrefix() + "ccapi_rci_functions.h";
    private static String CALLBACKS_NAME = ConfigGenerator.getCustomPrefix() + "ccapi_rci_functions.c";
    private static BufferedWriter headerWriter = null;
    private static BufferedWriter callbacksWriter = null;
    private String headerFile = "";
    private String callbacksFile = "";

	public FileSourceCcapi(String directoryPath) throws IOException {
		super(directoryPath,SOURCE_NAME,fileType);
        /* Need to create a header file + source file
         * fileWriter is source file writer.
         * So we need to create local header file.
         */
        headerFile = HEADER_NAME;
        callbacksFile = CALLBACKS_NAME;

        if(!ConfigGenerator.noBackupOption())
        {
        	super.checkPreviousBuild(filePath + headerFile);
        	super.checkPreviousBuild(filePath + callbacksFile);
        }

        headerWriter = new BufferedWriter(new FileWriter(filePath + headerFile));

        writeHeaderComment(headerWriter);
	}

    public void writeHeaderComment(BufferedWriter bufferWriter) throws IOException {
        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        Date date = new Date();

        String note_string = "/*\n * This is an auto-generated file - DO NOT EDIT! \n";

        if (bufferWriter == headerWriter)
            note_string += String.format(" * This is a H file generated by %s tool.\n", TOOL_NAME);
        else
            note_string += String.format(" * This is a C file generated by %s tool.\n", TOOL_NAME);


        note_string += String.format(" * This file was generated on: %s \n", dateFormat.format(date))
                     + String.format(" * The command line arguments were: %s\n", ConfigGenerator.getArgumentLogString())
                     + String.format(" * The version of %s tool was: %s */\n\n", TOOL_NAME, ConfigGenerator.VERSION);

        bufferWriter.write(note_string);

    }

    public void generateFile(ConfigData configData) throws Exception {
        try {

            /* write include header in the header file */
            String headerDefineName = headerFile.replace('.', '_').toLowerCase();
            headerWriter.write(String.format("#ifndef %s\n#define %s\n\n", headerDefineName, headerDefineName));
            headerWriter.write(String.format("%s \"%s\"\n\n", INCLUDE, "connector_api.h"));
            headerWriter.write(String.format("\n%s UNUSED_PARAMETER(a) (void)(a)\n",DEFINE));
            headerWriter.write("\nextern ccapi_rci_data_t const " + customPrefix + "ccapi_rci_data;\n");
            writePrototypes(configData, headerWriter);
            headerWriter.write(String.format("\n#endif\n"));

            if (ConfigGenerator.generateCcapiStubFunctions()) {
                callbacksWriter = new BufferedWriter(new FileWriter(filePath + callbacksFile));
                writeHeaderComment(callbacksWriter);

                callbacksWriter.write(String.format("%s <%s>\n", INCLUDE, "stdio.h"));
                callbacksWriter.write(String.format("%s \"%s\"\n", INCLUDE, "ccapi/ccapi.h"));
                callbacksWriter.write(String.format("%s \"%s\"\n\n", INCLUDE, headerFile));

                writeFunctionsCB(configData, callbacksWriter);

                ConfigGenerator.log(String.format("Files created:\n\t%s%s",  filePath, callbacksFile));

            }

            fileWriter.write(String.format("%s \"%s\"\n", INCLUDE, "ccapi/ccapi.h"));
            fileWriter.write(String.format("%s \"%s\"\n\n", INCLUDE, headerFile));

            /* write structures in source file */
            writeAllCcapiStructures(configData, fileWriter);

            generateUseNamesFile(configData);

            ConfigGenerator.log(String.format("Files created:\n\t%s%s",  filePath, generatedFile));
            if (generatedFile.length() > 0) {
                ConfigGenerator.log(String.format("\t%s%s", filePath, headerFile));
            }


        } catch (IOException e) {
            throw new IOException(e.getMessage());
        }

        finally {
            fileWriter.close();
            if (headerWriter != null) headerWriter.close();
            if (callbacksWriter != null) callbacksWriter.close();
        }

    }

    public static BufferedWriter getHeaderWriter(){
    	return headerWriter;
    }

    private void writeItemArrays(String prefix, ItemList list, BufferedWriter bufferWriter) throws Exception {
    	String current = String.format("static ccapi_rci_element_t const %s%s_elements[] = {",
        		customPrefix, getDefineString(prefix).toLowerCase());

        for (Item item: list.getItems()) {
            assert (item instanceof Element) || (item instanceof ItemList);

            if (item instanceof Element) {
                Element element = (Element) item;
                
                current += String.format("\n { %s", COMMENTED(element.getName()));

                if (getAccess(element.getAccess()).equalsIgnoreCase("read_only")) {
                	current += "   NULL,\n";
                }
                else {
                	current += String.format("   %s%srci_%s_%s_set,\n", RCI_FUNCTION_T, customPrefix, getDefineString(prefix).toLowerCase(),element.getName());
                }

                current += String.format("   %s%srci_%s_%s_get\n", RCI_FUNCTION_T, customPrefix, getDefineString(prefix).toLowerCase(),element.getName());
                current += " },";
            } else {
                ItemList items = (ItemList) item;

            	writeItemArrays(prefix + "_" + items.getName(), items, bufferWriter);

            	// TODO: Not sure what to do about lists in the CCAPI version quite yet. Making them NULL for now to trigger an error. -ASK
                current += 
                	String.format("\n { %s", COMMENTED(items.getName())) +
	            	"   NULL,\n" +
	            	"   NULL\n" +
	                " },";
            }
        }
        
        if (current.endsWith(",")) {
        	current = current.substring(0, current.length() - 1);
        }

        bufferWriter.write(current + "\n};\n\n");
    }
    
    private void writeGroupStructures(LinkedList<Group> groups, BufferedWriter bufferWriter) throws Exception {

        for (int group_index = 0; group_index < groups.size(); group_index++) {
            Group group = groups.get(group_index);

            /* write element structure */
            writeItemArrays(group.getName(), group, bufferWriter);
        }

    }

    protected void writeAllCcapiStructures(ConfigData configData, BufferedWriter bufferWriter) throws Exception {
        String define_name;

        for (GroupType type : GroupType.values()) {
            LinkedList<Group> groups = null;

            configType = type.toString().toLowerCase();

            groups = configData.getConfigGroup(configType);

            if (!groups.isEmpty()) {
                writeGroupStructures(groups, bufferWriter);

                bufferWriter.write(String.format("static ccapi_rci_group_t const %sccapi_%s_groups[] =\n{", customPrefix, configType));

                for (int group_index = 0; group_index < groups.size(); group_index++) {
                    Group group = groups.get(group_index);

                    define_name = getDefineString(group.getName() + "_elements");
                    String group_string = "";

                    group_string += String.format("\n    { %s", COMMENTED(group.getName()));
                    group_string += String.format("        %s%s,", customPrefix, define_name.toLowerCase());
                    group_string += String.format("\n        ARRAY_SIZE(%s%s),", customPrefix, define_name.toLowerCase());
                    group_string += String.format("\n        {");
                    group_string += String.format("\n            %s%srci_%s_start," , RCI_FUNCTION_T,customPrefix,getDefineString(group.getName()).toLowerCase());
            		group_string += String.format("\n            %s%srci_%s_end" , RCI_FUNCTION_T,customPrefix,getDefineString(group.getName()).toLowerCase());
                    group_string += String.format("\n        }");
                    group_string += String.format("\n    }");
                    if (group_index < (groups.size() - 1)) {
                    	group_string += String.format(",");
                    }
                    bufferWriter.write(group_string);
                }
                bufferWriter.write("\n};\n\n");
            }
        }

        String ccfsm_internal_data = "extern connector_remote_config_data_t const " + customPrefix + "rci_internal_data;\n";
        String ccapi_rci_data = ccfsm_internal_data + "ccapi_rci_data_t const " + customPrefix + "ccapi_rci_data =\n{";

        GroupType type = GroupType.SETTING;
        {
        	LinkedList<Group> groups = null;

            configType = type.toString().toLowerCase();
            groups = configData.getConfigGroup(configType);

        	ccapi_rci_data += String.format("\n    {");
            if (groups.isEmpty()) {
                ccapi_rci_data += String.format("\n        NULL,");
            	ccapi_rci_data += String.format("\n        0");
            }
            else {
            	ccapi_rci_data += String.format("\n        %sccapi_%s_groups,", customPrefix, configType);
            	ccapi_rci_data += String.format("\n        ARRAY_SIZE(%sccapi_%s_groups)", customPrefix, configType);
            }
        	ccapi_rci_data += String.format("\n    },");
        }

        type = GroupType.STATE;
        {
        	LinkedList<Group> groups = null;

            configType = type.toString().toLowerCase();
            groups = configData.getConfigGroup(configType);

        	ccapi_rci_data += String.format("\n    {");
            if (groups.isEmpty()) {
                ccapi_rci_data += String.format("\n        NULL,");
            	ccapi_rci_data += String.format("\n        0");
            }
            else {
            	ccapi_rci_data += String.format("\n        %sccapi_%s_groups,", customPrefix, configType);
            	ccapi_rci_data += String.format("\n        ARRAY_SIZE(%sccapi_%s_groups)", customPrefix, configType);
            }
        	ccapi_rci_data += String.format("\n    },");
        }

        ccapi_rci_data += String.format("\n    {");
        ccapi_rci_data += String.format("\n        %s%srci_session_start_cb,", RCI_FUNCTION_T, customPrefix);
        ccapi_rci_data += String.format("\n        %s%srci_session_end_cb,", RCI_FUNCTION_T, customPrefix);
        ccapi_rci_data += String.format("\n        %s%srci_action_start_cb,", RCI_FUNCTION_T, customPrefix);
        ccapi_rci_data += String.format("\n        %s%srci_action_end_cb", RCI_FUNCTION_T, customPrefix);
        if (ConfigGenerator.rciLegacyEnabled()) {
            ccapi_rci_data += String.format(",\n        %s%srci_do_command_cb,", RCI_FUNCTION_T, customPrefix);
            ccapi_rci_data += String.format("\n        %s%srci_set_factory_defaults_cb,", RCI_FUNCTION_T, customPrefix);
            ccapi_rci_data += String.format("\n        %s%srci_reboot_cb", RCI_FUNCTION_T, customPrefix);
        }
        ccapi_rci_data += String.format("\n    },");

        ccapi_rci_data += String.format("\n    &%srci_internal_data", customPrefix);
        ccapi_rci_data += "\n};\n\n";

        bufferWriter.write(ccapi_rci_data);
    }
}
