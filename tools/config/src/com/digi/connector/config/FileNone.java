package com.digi.connector.config;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import com.digi.connector.config.ConfigGenerator.FileType;

public class FileNone extends FileGenerator {

    private static String COPYRIGHT = "/*\n"
            +" * Copyright (c) 2018 Digi International Inc.\n"
            +" *\n"
            +" * This Source Code Form is subject to the terms of the Mozilla Public\n"
            +" * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n"
            +" * You can obtain one at http://mozilla.org/MPL/2.0/.\n"
            +" *\n"
            +" THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n"
            +" REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n"
            +" AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n"
            +" INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n"
            +" LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n"
            +" OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n"
            +" PERFORMANCE OF THIS SOFTWARE.\n"
            +" *\n"
            +" * Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343\n"
            +" * =======================================================================\n"
            +" */\n";

    protected final static String CONNECTOR_REMOTE_CONFIG_DATA = "typedef struct connector_remote_config_data {\n" +
    "    struct connector_remote_group_table const * group_table;\n" +
    "    char const * const * error_table;\n" +
    "    unsigned int global_error_count;\n" +
    "    uint32_t firmware_target_zero_version;\n" +
    "    uint32_t vendor_id;\n" +
    "    char const * device_type;\n" +
    "} connector_remote_config_data_t;\n";


    private static FileType fileType = FileType.NONE;
    private BufferedWriter functionWriter = null;
    private String functionFile = "";
    
    public FileNone(String directoryPath) throws IOException {
        
        super(directoryPath,HEADER_FILENAME,fileType);
        functionFile = "remote_config.c";

        if(!ConfigGenerator.noBackupOption())
            super.checkPreviousBuild(filePath + functionFile);

        functionWriter = new BufferedWriter(new FileWriter(filePath + functionFile));
        functionWriter.write(COPYRIGHT);
    }
    
    public void writeHeaderComment(BufferedWriter bufferWriter) throws IOException {
        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        Date date = new Date();

        String note_string = "/*\n * This is an auto-generated file - DO NOT EDIT! \n";
        
   
        note_string += String.format(" * This is generated by %s tool \n", TOOL_NAME);

        
        note_string += String.format(" * This file was generated on: %s \n", dateFormat.format(date))
                     + String.format(" * The command line arguments were: %s\n", ConfigGenerator.getArgumentLogString())
                     + String.format(" * The version of %s tool was: %s */\n\n", TOOL_NAME, ConfigGenerator.VERSION);

        note_string += COPYRIGHT;
        
        bufferWriter.write(note_string);
        
    }
    public void generateFile(ConfigData configData) throws Exception {
        try {

            String defineName = generatedFile.replace('.', '_').toUpperCase();
                       
            fileWriter.write(String.format("#ifndef %s\n#define %s\n\n", defineName, defineName));

            writeDefinesAndStructures(configData);
            
            /* Write all group enum in H file */
            writeRciErrorEnumHeader(configData, fileWriter);
            writeGlobalErrorEnumHeader(configData, fileWriter);

            writeGroupTypeAndErrorEnum(configData,fileWriter);

            fileWriter.write(CONNECTOR_REMOTE_CONFIG_DATA);

            fileWriter.write("\nextern connector_remote_config_data_t const * const rci_descriptor_data;\n\n");

            fileWriter.write("\n#if !defined _CONNECTOR_API_H\n");
            fileWriter.write("#error  \"Illegal inclusion of connector_api_remote.h. You should only include connector_api.h in user code.\"\n");
            fileWriter.write("#endif\n\n");
            fileWriter.write("#else\n");
            fileWriter.write("#error  \"Illegal inclusion of connector_api_remote.h. You should only include connector_api.h in user code.\"\n");
            fileWriter.write("#endif\n");
            
            /*Write function file */
            writeFunctionFile(configData, functionWriter);
            
                       
            ConfigGenerator.log(String.format("Files created:\n\t%s%s",  filePath, generatedFile));
            if (generatedFile.length() > 0) ConfigGenerator.log(String.format("\t%s%s", filePath, functionFile));

        } catch (IOException e) {
            throw new IOException(e.getMessage());
        }

        finally {
            fileWriter.close();
            functionWriter.close();
        }

    }
    
    private void writeFunctionFile(ConfigData configData, BufferedWriter bufferWriter) throws Exception
    {
        bufferWriter.write(String.format("%s", CONNECTOR_GLOBAL_HEADER));

        /*
         * Start writing:
         * 1. all #define for all strings from user's groups
         * 2. all #define for all RCI and user's global errors
         * 3. all strings in connector_remote_all_strings[]
         */
        bufferWriter.write("\n\n#define CONST const \n");

        /* Write Define Errors Macros */
        writeDefineRciErrors(configData,bufferWriter);

        writeDefineGroupErrors(configData,bufferWriter);

        writeDefineGlobalErrors(configData,bufferWriter);

        /* write remote all strings in source file */
        writeRemoteAllStrings(configData,bufferWriter);

        /* write connector_rci_errors[] */
        writeGlobalErrorStructures(configData,bufferWriter);

        /* write structures in source file */
        writeAllStructures(configData,bufferWriter);

        int GlobalErrorCount = configData.getUserGlobalErrors().size() + configData.rciGlobalErrors.size();

        bufferWriter.write(String.format("\nconnector_remote_config_data_t const %srci_internal_data = {\n" +
            "    connector_group_table,\n"+
            "    connector_rci_errors,\n"+
            "    %d,\n"+
            "    0x%X,\n"+
            "    %s,\n"+
            "    \"%s\"\n"+
            "};\n"+
            "\n"+
            "connector_remote_config_data_t const * const rci_descriptor_data = &%srci_internal_data;"
            , customPrefix, GlobalErrorCount, ConfigGenerator.getFirmware(), Descriptors.vendorId(),Descriptors.deviceType(), customPrefix));
    }
}